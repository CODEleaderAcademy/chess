<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Human VS Human</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #000000;
      text-align: center;
      margin-top: 20px;
    }
    h1 {
      font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
      color: #f9d423;
    }
    #chessboard {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      margin: 0 auto;
      border: 3px solid #f9d423;
      width: 485px;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      user-select: none;
    }
    .white {
      background-color: rgb(211, 210, 210);
    }
    .black {
      background-color: gray;
    }
    .selected {
      outline: 3px solid red;
    }
    #status {
      margin-top: 10px;
      font-weight: bold;
      min-height: 1.5em;
      color: white;
    }
    #controls {
      margin-top: 15px;
    }
    #promotion-bar {
      margin-top: 20px;
      display: none;
      justify-content: center;
      gap: 10px;
    }
    .promo-piece {
      font-size: 40px;
      cursor: pointer;
      padding: 5px 10px;
      border: 2px solid transparent;
      user-select: none;
      border-radius: 6px;
      transition: border-color 0.3s;
      background: white;
      width: 60px;
      text-align: center;
      line-height: 1;
    }
    .promo-piece:hover {
      border-color: #ff4500;
      background: #ffe4e1;
    }
    #checkmate-banner {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(45deg, #ff4e50, #f9d423);
      color: white;
      font-size: 48px;
      font-weight: bold;
      padding: 20px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      animation: popIn 0.7s ease-out forwards;
      user-select: none;
    }
    @keyframes popIn {
      0% { opacity: 0; transform: translate(-50%, -20%) scale(0.8); }
      100% { opacity: 1; transform: translate(-50%, 0) scale(1); }
    }
    button { margin-bottom: 10px; }
    #draw-banner {
      display: none;
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(45deg, #4b6cb7, #182848);
      color: white;
      font-size: 48px;
      font-weight: bold;
      padding: 20px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      animation: popIn 0.7s ease-out forwards;
      user-select: none;
    }
  </style>
</head>
<body>

<h1>Human VS Human</h1>

<div id="promotion-bar">
  <div class="promo-piece" data-type="Q" title="Queen"></div>
  <div class="promo-piece" data-type="R" title="Rook"></div>
  <div class="promo-piece" data-type="B" title="Bishop"></div>
  <div class="promo-piece" data-type="N" title="Knight"></div>
</div>
<div id="chessboard"></div>
<p id="status"></p>
<div id="controls">
  <a href="homescreen.html"><button type="button" class="btn btn-dark">Back To Homescreen</button></a>
  <button id="undoBtn" title="Undo Move" type="button" class="btn btn-dark">↩️ Undo</button>
  <button id="redoBtn" title="Redo Move" type="button" class="btn btn-dark">↪️ Redo</button>
</div>

<div id="checkmate-banner">Checkmate!</div>
<div id="draw-banner">Draw!</div>

<script>
  // --- DOM Elements ---
  const board = document.getElementById("chessboard");
  const status = document.getElementById("status");
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const promotionBar = document.getElementById("promotion-bar");
  const promoPieces = promotionBar.querySelectorAll(".promo-piece");
  const checkmateBanner = document.getElementById("checkmate-banner");
  const drawBanner = document.getElementById("draw-banner");

  // --- Game State Variables ---
  let selectedSquare = null; // Stores the currently selected square HTML element
  let currentTurn = "white";
  let gameOver = false;

  // Unicode chess pieces
  const pieces = {
    white: { K: "♔", Q: "♕", R: "♖", B: "♗", N: "♘", P: "♙" },
    black: { K: "♚", Q: "♛", R: "♜", B: "♝", N: "♞", P: "♟" },
  };

  // Initial board setup
  let boardState = [
    [
      { type: "R", color: "black" }, { type: "N", color: "black" }, { type: "B", color: "black" }, { type: "Q", color: "black" },
      { type: "K", color: "black" }, { type: "B", color: "black" }, { type: "N", color: "black" }, { type: "R", color: "black" }
    ],
    Array(8).fill(null).map(() => ({ type: "P", color: "black" })),
    Array(8).fill(null),
    Array(8).fill(null),
    Array(8).fill(null),
    Array(8).fill(null),
    Array(8).fill(null).map(() => ({ type: "P", color: "white" })),
    [
      { type: "R", color: "white" }, { type: "N", color: "white" }, { type: "B", color: "white" }, { type: "Q", color: "white" },
      { type: "K", color: "white" }, { type: "B", color: "white" }, { type: "N", color: "white" }, { type: "R", color: "white" }
    ]
  ];

  // History for undo/redo
  let undoStack = [];
  let redoStack = [];

  // Promotion related
  let promotionPending = null; // Stores { row, col, color } for pawn awaiting promotion

  // En Passant target square {row, col}, or null if no target
  let enPassantTarget = null;

  // For 50-move rule
  let moveCountSinceLastCaptureOrPawnMove = 0;

  // For Threefold Repetition rule
  let positionHistory = [];

  // Castling rights for white and black
  let castlingRights = {
    white: { kingMoved: false, rookA: false, rookH: false }, // rookA for a-file rook (queenside), rookH for h-file rook (kingside)
    black: { kingMoved: false, rookA: false, rookH: false }
  };

  // --- Helper Functions ---

  // Deep clones the board state to prevent mutation issues
  function cloneBoard(board) {
    return board.map(row => row.map(piece => piece ? { ...piece } : null));
  }

  // Saves the current game state to the undo stack
  function saveState() {
    undoStack.push({
      board: cloneBoard(boardState),
      castlingRights: JSON.parse(JSON.stringify(castlingRights)), // Deep clone castling rights
      currentTurn: currentTurn,
      gameOver: gameOver,
      enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null, // Clone en passant target
      moveCountSinceLastCaptureOrPawnMove: moveCountSinceLastCaptureOrPawnMove
    });
    redoStack = []; // Clear redo stack on new move
    updateUndoRedoButtons();
    // Add current position string to history for threefold repetition
    positionHistory.push(JSON.stringify(boardState) + currentTurn + JSON.stringify(castlingRights) + (enPassantTarget ? JSON.stringify(enPassantTarget) : ""));
  }

  // Updates the disabled state of undo/redo buttons
  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  // Renders the chessboard based on the current boardState
  function renderBoard() {
    board.innerHTML = "";
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const sq = document.createElement("div");
        sq.classList.add("square");
        sq.classList.add((r + c) % 2 === 0 ? "white" : "black");
        const piece = boardState[r][c];
        if (piece) sq.textContent = pieces[piece.color][piece.type];
        sq.dataset.row = r;
        sq.dataset.col = c;
        sq.addEventListener("click", onSquareClick);
        board.appendChild(sq);
      }
    }
    // Update status message, unless promotion is pending
    if (!gameOver && !promotionPending) {
      status.textContent = `Turn: ${capitalize(currentTurn)}`;
    }
  }

  // Capitalizes the first letter of a string
  function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  // Finds the king's position for a given color on a specific board
  function findKingForBoard(color, board) {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (p && p.type === "K" && p.color === color) return { r, c };
      }
    }
    return null;
  }

  // Checks if a specific square is attacked by a piece of 'byColor' on a given board
  function isSquareAttackedForBoard(r, c, byColor, board) {
    for (let rr = 0; rr < 8; rr++) {
      for (let cc = 0; cc < 8; cc++) {
        const p = board[rr][cc];
        if (p && p.color === byColor) {
          // Use isLegalMoveForPiece, but ensure it doesn't check for self-check on the king
          // as we are checking if *any* piece can attack the square.
          if (isLegalMoveForPiece(rr, cc, r, c, board, false)) return true; // Pass false to skip self-check logic
        }
      }
    }
    return false;
  }

  // Checks if the king of 'color' is in check on a specific board
  function isInCheckForBoard(color, board) {
    const kingPos = findKingForBoard(color, board);
    if (!kingPos) return false; // Should not happen in a valid game
    const opponent = color === "white" ? "black" : "white";
    return isSquareAttackedForBoard(kingPos.r, kingPos.c, opponent, board);
  }

  // Simplified check if the current player's king is in check on the main board
  function isInCheck(color) {
    return isInCheckForBoard(color, boardState);
  }

  // Determines if a basic move for a specific piece type is valid (without self-check validation)
  function isLegalMoveForPiece(fr, fc, tr, tc, board, checkSelfCheck = true) {
    const piece = board[fr][fc];
    if (!piece) return false;

    const target = board[tr][tc];
    // A piece cannot move to a square occupied by its own color, unless it's a special move (handled elsewhere)
    if (target && target.color === piece.color) return false;

    const dr = tr - fr;
    const dc = tc - fc;

    switch (piece.type) {
      case "P":
        return isLegalPawnMove(piece.color, fr, fc, tr, tc, board);
      case "R":
        return (dr === 0 || dc === 0) && isPathClear(fr, fc, tr, tc, board);
      case "N":
        return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
      case "B":
        return (Math.abs(dr) === Math.abs(dc)) && isPathClear(fr, fc, tr, tc, board);
      case "Q":
        return ((dr === 0 || dc === 0) || (Math.abs(dr) === Math.abs(dc))) &&
               isPathClear(fr, fc, tr, tc, board);
      case "K":
        // Basic king move (1 square in any direction)
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return true;
        // Castling is handled in canCastle, not here for basic piece movement
        return false;
    }
    return false;
  }

  // Checks if the path between two squares is clear for Rooks, Bishops, and Queens
  function isPathClear(fr, fc, tr, tc, board = boardState) {
    const dr = Math.sign(tr - fr);
    const dc = Math.sign(tc - fc);
    let r = fr + dr;
    let c = fc + dc;
    while (r !== tr || c !== tc) {
      if (board[r][c]) return false;
      r += dr;
      c += dc;
    }
    return true;
  }

  // Checks if a pawn move is legal (including initial two-square move, captures, and en passant)
  function isLegalPawnMove(color, fr, fc, tr, tc, board = boardState) {
    const direction = color === "white" ? -1 : 1; // White moves up (-1 row), Black moves down (+1 row)
    const startRow = color === "white" ? 6 : 1; // Starting row for pawns

    const target = board[tr][tc]; // Piece at the target square

    // 1. Straight move (no capture)
    if (fc === tc) {
      if (tr === fr + direction && !target) { // Single square move
        return true;
      }
      if (fr === startRow && tr === fr + 2 * direction && !target && !board[fr + direction][fc]) {
        // Initial two-square move (path must be clear)
        return true;
      }
      return false; // Invalid straight move
    }

    // 2. Diagonal capture or En Passant
    if (Math.abs(tc - fc) === 1 && tr === fr + direction) { // Diagonal move
      // Regular diagonal capture
      if (target && target.color !== color) {
        return true;
      }
      // En Passant capture
      // Target square must be empty
      // The enPassantTarget must be set for this specific square
      // The captured pawn must be at (fr, tc) and be an opponent's pawn
      if (!target && enPassantTarget && tr === enPassantTarget.row && tc === enPassantTarget.col) {
        const capturedPawn = board[fr][tc]; // The pawn to be captured is on the same row as attacking pawn, but target column
        if (capturedPawn && capturedPawn.type === "P" && capturedPawn.color !== color) {
          return true;
        }
      }
    }
    return false; // Invalid diagonal move
  }

  // Checks if castling is legal for the given color and move
  function canCastle(color, fromR, fromC, toR, toC) {
    // 1. King and Rook must not have moved
    if (castlingRights[color].kingMoved) return false;

    const row = color === "white" ? 7 : 0;
    let rookCol;
    let pathCols;
    let attackCheckCols;

    if (toC === 6) { // Kingside castle (O-O)
      rookCol = 7;
      pathCols = [5, 6];
      attackCheckCols = [4, 5, 6]; // King cannot pass through or land on attacked squares
      if (castlingRights[color].rookH) return false;
    } else if (toC === 2) { // Queenside castle (O-O-O)
      rookCol = 0;
      pathCols = [1, 2, 3];
      attackCheckCols = [4, 3, 2]; // King cannot pass through or land on attacked squares
      if (castlingRights[color].rookA) return false;
    } else {
      return false; // Not a castling target column
    }

    // 2. Rook must be in its starting position
    const rook = boardState[row][rookCol];
    if (!rook || rook.type !== "R" || rook.color !== color) return false;

    // 3. Path between king and rook must be empty
    for (let c of pathCols) {
      if (boardState[row][c]) return false;
    }

    // 4. King must not be in check, and must not pass through or land on a square that is attacked
    const opponent = color === "white" ? "black" : "white";
    for (let c of attackCheckCols) {
      if (isSquareAttackedForBoard(row, c, opponent, boardState)) return false;
    }
    return true;
  }

  // The main move validation function. Ensures the move is valid and doesn't leave king in check.
  function isLegalMove(fr, fc, tr, tc) {
    const piece = boardState[fr][fc];
    if (!piece) return false;
    const target = boardState[tr][tc];
    if (target && target.color === piece.color) return false; // Cannot capture own piece

    const dr = tr - fr;
    const dc = tc - fc;

    // Handle Castling as a special move first
    if (piece.type === "K" && Math.abs(dc) === 2 && dr === 0) {
      return canCastle(piece.color, fr, fc, tr, tc);
    }

    // Basic move validation for the piece type
    if (!isLegalMoveForPiece(fr, fc, tr, tc, boardState)) {
      return false;
    }

    // Simulate the move on a temporary board to check for self-check
    const tempBoard = cloneBoard(boardState);
    tempBoard[tr][tc] = tempBoard[fr][fc]; // Move piece to target
    tempBoard[fr][fc] = null; // Clear original square

    // Handle En Passant capture on the temp board
    // This needs to be consistent with how isLegalPawnMove validates en passant
    if (piece.type === "P" && Math.abs(tc - fc) === 1 && !target && enPassantTarget && tr === enPassantTarget.row && tc === enPassantTarget.col) {
        tempBoard[fr][tc] = null; // Remove the captured pawn on the temp board
    }

    let kingPos;
    if (piece.type === "K") {
      kingPos = { r: tr, c: tc }; // King moved to (tr, tc)
    } else {
      kingPos = findKingForBoard(piece.color, tempBoard); // Find king on temp board
    }

    // After the hypothetical move, check if the king is in check
    if (isInCheckForBoard(piece.color, tempBoard)) {
      return false; // Move is illegal as it leaves the king in check
    }
    return true; // Move is legal
  }

  // --- Game End Conditions ---

  // Checks if the current player is in checkmate
  function isCheckmate(color) {
    if (!isInCheck(color)) return false; // Not checkmate if not in check

    // Iterate through all pieces of the current player
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const p = boardState[r][c];
        if (p && p.color === color) {
          // Check all possible squares for this piece
          for (let rr = 0; rr < 8; rr++) {
            for (let cc = 0; cc < 8; cc++) {
              // If there's any legal move that gets the king out of check, it's not checkmate
              if (isLegalMove(r, c, rr, cc)) {
                return false;
              }
            }
          }
        }
      }
    }
    return true; // No legal moves found to escape check
  }

  // Checks if the current player is in stalemate
  function isStalemate() {
    if (isInCheck(currentTurn)) return false; // Not stalemate if in check

    // Check if there are ANY legal moves for the current player
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const p = boardState[r][c];
        if (p && p.color === currentTurn) {
          for (let rr = 0; rr < 8; rr++) {
            for (let cc = 0; cc < 8; cc++) {
              if (isLegalMove(r, c, rr, cc)) {
                return false; // Found a legal move, so not stalemate
              }
            }
          }
        }
      }
    }
    return true; // No legal moves found, and not in check = stalemate
  }

  // Checks for Threefold Repetition
  function isThreefoldRepetition() {
    const currentPosition = JSON.stringify(boardState) + currentTurn + JSON.stringify(castlingRights) + (enPassantTarget ? JSON.stringify(enPassantTarget) : "");
    let count = 0;
    for (const position of positionHistory) {
      if (position === currentPosition) {
        count++;
        if (count >= 3) return true;
      }
    }
    return false;
  }

  // Checks for Insufficient Material (simplistic)
  function isInsufficientMaterial() {
    let whitePieces = [];
    let blackPieces = [];

    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const p = boardState[r][c];
        if (p) {
          if (p.color === "white") whitePieces.push(p.type);
          else blackPieces.push(p.type);
        }
      }
    }

    // King vs King
    if (whitePieces.length === 1 && whitePieces[0] === "K" &&
        blackPieces.length === 1 && blackPieces[0] === "K") return true;

    // King and Knight vs King
    if (whitePieces.length === 2 && whitePieces.includes("K") && whitePieces.includes("N") &&
        blackPieces.length === 1 && blackPieces[0] === "K") return true;
    if (blackPieces.length === 2 && blackPieces.includes("K") && blackPieces.includes("N") &&
        whitePieces.length === 1 && whitePieces[0] === "K") return true;

    // King and Bishop vs King
    if (whitePieces.length === 2 && whitePieces.includes("K") && whitePieces.includes("B") &&
        blackPieces.length === 1 && blackPieces[0] === "K") return true;
    if (blackPieces.length === 2 && blackPieces.includes("K") && blackPieces.includes("B") &&
        whitePieces.length === 1 && whitePieces[0] === "K") return true;

    // King and Bishop vs King and Bishop (on same color squares)
    if (whitePieces.length === 2 && whitePieces.includes("K") && whitePieces.includes("B") &&
        blackPieces.length === 2 && blackPieces.includes("K") && blackPieces.includes("B")) {
      let whiteBishopPos = null;
      let blackBishopPos = null;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = boardState[r][c];
          if (p && p.type === "B") {
            if (p.color === "white") whiteBishopPos = { r, c };
            else blackBishopPos = { r, c };
          }
        }
      }
      // If both bishops are on squares of the same color
      if (whiteBishopPos && blackBishopPos &&
          ((whiteBishopPos.r + whiteBishopPos.c) % 2 === (blackBishopPos.r + blackBishopPos.c) % 2)) {
        return true;
      }
    }

    return false;
  }

  // --- UI Banners ---

  function showCheckmateBanner() {
    checkmateBanner.style.display = "block";
  }

  function showDrawBanner() {
    drawBanner.style.display = "block";
  }

  function hideBanners() {
    checkmateBanner.style.display = "none";
    drawBanner.style.display = "none";
  }

  // --- Event Handlers ---

  function onSquareClick(e) {
    if (gameOver || promotionPending) return; // Prevent interaction if game over or promoting

    const r = +e.target.dataset.row;
    const c = +e.target.dataset.col;
    const clickedPiece = boardState[r][c];

    if (selectedSquare) {
      // A piece is already selected, so this click is an attempt to move
      const fromR = +selectedSquare.dataset.row;
      const fromC = +selectedSquare.dataset.col;
      const selectedPiece = boardState[fromR][fromC];

      // Ensure the selected piece belongs to the current turn's player
      if (!selectedPiece || selectedPiece.color !== currentTurn) {
        selectedSquare.classList.remove("selected");
        selectedSquare = null;
        return; // Clicked on opponent's piece or empty square after selecting own
      }

      // --- Attempt the Move ---
      // isLegalMove handles all legality checks, including leaving king in check.
      if (isLegalMove(fromR, fromC, r, c)) {
        // --- Save State BEFORE modifying the board for the current move ---
        saveState();

        const piece = boardState[fromR][fromC]; // The piece being moved
        const target = boardState[r][c]; // The piece at the destination square (could be null)
        let isCapture = target !== null; // Flag for 50-move rule
        let isPawnMove = piece.type === "P"; // Flag for 50-move rule

        // Handle En Passant capture (remove the captured pawn from its actual location)
        // This specific check ensures it was an en passant move (diagonal pawn move to empty square)
        if (isPawnMove && Math.abs(c - fromC) === 1 && !target && enPassantTarget && r === enPassantTarget.row && c === enPassantTarget.col) {
            boardState[fromR][tc] = null; // Remove the pawn from its original square
            isCapture = true; // En passant is a capture
        }

        // --- Execute the Move on the Actual Board ---
        boardState[r][c] = piece;
        boardState[fromR][fromC] = null;

        // Handle Castling Rook move
        if (piece.type === "K" && Math.abs(c - fromC) === 2) {
          if (c === 6) { // Kingside castle
            boardState[r][5] = boardState[r][7]; // Move rook from h-file to f-file
            boardState[r][7] = null;
          } else if (c === 2) { // Queenside castle
            boardState[r][3] = boardState[r][0]; // Move rook from a-file to d-file
            boardState[r][0] = null;
          }
        }

        // --- Update Game State Flags AFTER Move ---

        // Update Castling Rights (if King or Rook moved from starting position)
        if (piece.type === "K") {
          castlingRights[piece.color].kingMoved = true;
        } else if (piece.type === "R") {
          if (fromC === 0) castlingRights[piece.color].rookA = true;
          else if (fromC === 7) castlingRights[piece.color].rookH = true;
        }

        // Set En Passant Target for the *next* turn
        enPassantTarget = null; // Reset previous turn's target
        if (piece.type === "P" && Math.abs(r - fromR) === 2) { // If pawn moved two squares
          // The target square for en passant is the square *behind* the moved pawn
          enPassantTarget = { row: (r + fromR) / 2, col: c };
        }

        // Update 50-move rule counter
        if (isPawnMove || isCapture) {
          moveCountSinceLastCaptureOrPawnMove = 0; // Reset if pawn move or capture
        } else {
          moveCountSinceLastCaptureOrPawnMove++; // Increment otherwise
        }

        // --- Handle Pawn Promotion ---
        if (piece.type === "P" && (r === 0 || r === 7)) {
          promotionPending = { row: r, col: c, color: piece.color };
          showPromotionBar(piece.color);
          renderBoard(); // Re-render to show pawn at promotion square
          selectedSquare.classList.remove("selected");
          selectedSquare = null; // Deselect pawn
          status.textContent = `Choose a piece to promote your pawn`;
          return; // Stop here, wait for promotion choice
        }

        // --- Clean up Selection and Switch Turn ---
        selectedSquare.classList.remove("selected");
        selectedSquare = null;
        currentTurn = currentTurn === "white" ? "black" : "white"; // Switch turn

        renderBoard(); // Re-render board with the new state

        // --- Check for Game End Conditions (after turn changes) ---
        // These checks apply to the *new* currentTurn player
        if (isStalemate()) {
          status.textContent = "Stalemate! Game drawn!";
          gameOver = true;
          showDrawBanner();
          return;
        }
        if (isThreefoldRepetition()) {
          status.textContent = "Threefold repetition! Game drawn!";
          gameOver = true;
          showDrawBanner();
          return;
        }
        if (moveCountSinceLastCaptureOrPawnMove >= 50) {
          status.textContent = "50-move rule! Game drawn!";
          gameOver = true;
          showDrawBanner();
          return;
        }
        if (isInsufficientMaterial()) {
          status.textContent = "Insufficient material! Game drawn!";
          gameOver = true;
          showDrawBanner();
          return;
        }

        // Check if the new player is in check (or checkmate)
        if (isInCheck(currentTurn)) {
          if (isCheckmate(currentTurn)) {
            status.textContent = `Checkmate! ${capitalize(currentTurn === "white" ? "black" : "white")} wins!`;
            gameOver = true;
            showCheckmateBanner();
          } else {
            status.textContent = `Check! ${capitalize(currentTurn)}'s turn.`;
          }
        } else {
          status.textContent = `Turn: ${capitalize(currentTurn)}`;
        }

      } else { // Move was not legal
        status.textContent = "Illegal move!";
        if (isInCheck(currentTurn)) {
          status.textContent = "Illegal move: You must get your King out of check!";
        }
        selectedSquare.classList.remove("selected");
        selectedSquare = null;
      }
    } else {
      // No piece is selected yet, so this click is to select a piece
      if (clickedPiece && clickedPiece.color === currentTurn) {
        selectedSquare = e.target;
        selectedSquare.classList.add("selected");
        status.textContent = `Selected ${clickedPiece.color} ${clickedPiece.type}`;
      } else if (clickedPiece && clickedPiece.color !== currentTurn) {
        status.textContent = `It's ${capitalize(currentTurn)}'s turn.`;
      } else {
        status.textContent = "Select a piece to move.";
      }
    }
  }

  // --- Undo/Redo Logic ---

  undoBtn.addEventListener("click", () => {
    if (undoStack.length === 0) return;

    // Save current state to redo stack before undoing
    redoStack.push({
      board: cloneBoard(boardState),
      castlingRights: JSON.parse(JSON.stringify(castlingRights)),
      currentTurn: currentTurn,
      gameOver: gameOver,
      enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
      moveCountSinceLastCaptureOrPawnMove: moveCountSinceLastCaptureOrPawnMove
    });

    const prevState = undoStack.pop(); // Get the previous state
    boardState = cloneBoard(prevState.board);
    castlingRights = JSON.parse(JSON.stringify(prevState.castlingRights));
    currentTurn = prevState.currentTurn;
    gameOver = prevState.gameOver;
    enPassantTarget = prevState.enPassantTarget ? { ...prevState.enPassantTarget } : null;
    moveCountSinceLastCaptureOrPawnMove = prevState.moveCountSinceLastCaptureOrPawnMove;

    promotionPending = null; // Clear any pending promotion
    promotionBar.style.display = "none";
    selectedSquare = null; // Clear selected square
    hideBanners(); // Hide checkmate/draw banners

    renderBoard();
    updateUndoRedoButtons();
    status.textContent = `Turn: ${capitalize(currentTurn)}`;
    // Remove the last position from history to match the undo
    positionHistory.pop();
  });

  redoBtn.addEventListener("click", () => {
    if (redoStack.length === 0) return;

    // Save current state to undo stack before redoing
    undoStack.push({
      board: cloneBoard(boardState),
      castlingRights: JSON.parse(JSON.stringify(castlingRights)),
      currentTurn: currentTurn,
      gameOver: gameOver,
      enPassantTarget: enPassantTarget ? { ...enPassantTarget } : null,
      moveCountSinceLastCaptureOrPawnMove: moveCountSinceLastCaptureOrPawnMove
    });

    const nextState = redoStack.pop(); // Get the next state
    boardState = cloneBoard(nextState.board);
    castlingRights = JSON.parse(JSON.stringify(nextState.castlingRights));
    currentTurn = nextState.currentTurn;
    gameOver = nextState.gameOver;
    enPassantTarget = nextState.enPassantTarget ? { ...nextState.enPassantTarget } : null;
    moveCountSinceLastCaptureOrPawnMove = nextState.moveCountSinceLastCaptureOrPawnMove;

    promotionPending = null; // Clear any pending promotion
    promotionBar.style.display = "none";
    selectedSquare = null; // Clear selected square
    hideBanners(); // Hide checkmate/draw banners

    renderBoard();
    updateUndoRedoButtons();
    status.textContent = `Turn: ${capitalize(currentTurn)}`;
    // Add the re-done position to history
    positionHistory.push(JSON.stringify(boardState) + currentTurn + JSON.stringify(castlingRights) + (enPassantTarget ? JSON.stringify(enPassantTarget) : ""));
  });

  // --- Promotion Bar Logic ---

  function showPromotionBar(color) {
    promotionBar.style.display = "flex";
    promoPieces.forEach(div => {
      div.textContent = pieces[color][div.dataset.type]; // Set unicode for pieces based on pawn color
    });
  }

  promoPieces.forEach(div => {
    div.addEventListener("click", () => {
      if (!promotionPending) return; // Only process if a promotion is pending

      const { row, col, color } = promotionPending;
      const choice = div.dataset.type; // Get chosen piece type (Q, R, B, N)

      boardState[row][col] = { type: choice, color }; // Update the pawn to the chosen piece
      promotionPending = null; // Clear promotion flag
      promotionBar.style.display = "none"; // Hide promotion bar

      currentTurn = currentTurn === "white" ? "black" : "white"; // Switch turn

      renderBoard(); // Re-render board with the promoted piece

      // Re-check game end conditions after promotion
      if (isStalemate()) {
        status.textContent = "Stalemate! Game drawn!";
        gameOver = true;
        showDrawBanner();
        return;
      }
      if (isThreefoldRepetition()) {
        status.textContent = "Threefold repetition! Game drawn!";
        gameOver = true;
        showDrawBanner();
        return;
      }
      if (isInsufficientMaterial()) {
        status.textContent = "Insufficient material! Game drawn!";
        gameOver = true;
        showDrawBanner();
        return;
      }
      if (isInCheck(currentTurn)) {
        if (isCheckmate(currentTurn)) {
          status.textContent = `Checkmate! ${capitalize(currentTurn === "white" ? "black" : "white")} wins!`;
          gameOver = true;
          showCheckmateBanner();
        } else {
          status.textContent = `Check! ${capitalize(currentTurn)}'s turn.`;
        }
      } else {
        status.textContent = `Turn: ${capitalize(currentTurn)}`;
      }
    });
  });

  // --- Initial Game Setup ---
  renderBoard();
  updateUndoRedoButtons(); // Initialize button states
</script>
</body>
</html>
